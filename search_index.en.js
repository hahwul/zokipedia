window.searchIndex = [{"url":"https://zokipedia.hahwul.com/","title":"Zokipedia","body":"Welcome to Zokipedia, your comprehensive knowledge base.\n"},{"url":"https://zokipedia.hahwul.com/get-started/","title":"Get Started","body":"Zokipedia is a theme for Zola. To use this documentation, you need to install Zola first. You can install it on various operating systems with a simple command like the one below.\n\nFor more details, please refer to the official installation guide on the Zola website.\nOnce you have Zola installed, create a new Zola site as follows:\n\nYou can then run the local development server with the zola serve command and view your site at http://localhost:1111.\nInstall the zokipedia Theme\nThe easiest way to install a theme in Zola is to clone it or add it as a submodule into the themes subdirectory of your Zola project.\nClone example\n\nSubmodule example\n\nUpdate the zokipedia Theme\nIf you want to update the zokipedia theme to the latest version, you can do so easily:\n\n\nIf you cloned the theme:\n\n\n\nIf you added the theme as a submodule:\n\n\n\nThis will ensure you always have the latest features and fixes from the zokipedia theme.\nSet the theme in config.toml\nThis is the final step. Set the theme in your config.toml file to use zokipedia. Below are the configuration options you can customize, grouped by category.\nBasic Site Configuration\nThese are the fundamental settings for your site, including the base URL, title, description, and theme selection.\n\nBuild and Compilation Settings\nConfigure how Zola builds your site, such as compiling Sass files and building a search index.\n\nMarkdown Configuration\nSettings related to Markdown processing, like syntax highlighting for code blocks.\n\nSearch Configuration\nConfigure the search functionality, including the index format.\n\nExtra Configuration\nAdditional theme-specific settings under the [extra] table.\nNavigation Links\nNavigation links appear in the header on the right side. Each link can have a name, URL, and optionally an icon (e.g., \"github\").\n\nNavigation Height\nSet the height of the top navigation in pixels. The default is 64px.\n\nFooter Configuration\nConfigure the footer with text links and copyright text.\n\nNow, when you run Zola, it will use the zokipedia theme.\n\nHowever, since you don't have any content yet, you will only see a blank page with a brilliant color. In the next document, we'll create our first page.\n"},{"url":"https://zokipedia.hahwul.com/styleguide/","title":"Style Guide","body":"Markdown Style Guide\nThis document provides examples of various Markdown syntax elements to demonstrate proper usage.\nHeaders\nH1 Header\nH2 Header\nH3 Header\nH4 Header\nH5 Header\nH6 Header\nEmphasis\nItalic text or italic text\nBold text or bold text\nBold and italic or bold and italic\nLists\nUnordered List\n\nItem 1\nItem 2\n\nSubitem 2.1\nSubitem 2.2\n\n\n\nOrdered List\n\nFirst item\nSecond item\n\nSubitem 2.1\nSubitem 2.2\n\n\n\nLinks\nLink text\nLink with title\nImages\n\n\nCode\nInline code here.\n\nBlockquotes\n\nThis is a blockquote.\nThis is another line in the blockquote.\n\nHorizontal Rules\n\nTables\nHeader 1Header 2\nCell 1Cell 2\nCell 3Cell 4\n\nFootnotes\nHere's a sentence with a footnote.1\n1\nThis is the footnote.\n\nTask Lists\n\n\nCompleted task\n\nIncomplete task\n\nStrikethrough\nStrikethrough text\n"},{"url":"https://zokipedia.hahwul.com/shortcodes/","title":"Short Codes","body":"Zokipedia supports several shortcodes to enhance your content.\nMath\nUse the math shortcode to render mathematical expressions.\n\\sum_{i=0}^{n} r^i = \\frac{r^{n+1} - 1}{r - 1} \\quad \\text{for } r \\neq 1\n\nMermaid\nUse the mermaid shortcode to create diagrams.\n\n\n"},{"url":"https://zokipedia.hahwul.com/algorithm-complexity/","title":"[Example] Algorithm Complexity","body":"Understanding algorithmic complexity is essential for writing efficient, scalable software and for communicating performance trade-offs. This guide combines precise definitions with practical tips, common pitfalls, and reference formulas you can use in day-to-day engineering.\nWhat do we measure?\n\nTime complexity: how running time scales with input size n under a chosen model of computation (often a unit-cost RAM model with word size w = Θ(log n)).\nSpace complexity: how memory usage scales with n (peak or additional space).\nInput size: number of items (n elements), bit-length of numeric values, number of vertices/edges (V, E), etc. Always state which input model you use.\n\nReal-world note: the same asymptotic complexity can lead to very different wall-clock performance due to constants, memory locality, parallelism, and hardware effects.\nAsymptotic notation (precise definitions)\nLet f(n) and g(n) be nonnegative for sufficiently large n.\n\n\nBig-O (upper bound):\nf(n) = O(g(n)) \\iff \\exists c&gt;0,\\, n_0\\ge 1:\\ \\forall n\\ge n_0,\\ 0 \\le f(n) \\le c\\,g(n)\n\n\n\nBig-Ω (lower bound):\nf(n) = \\Omega(g(n)) \\iff \\exists c&gt;0,\\, n_0:\\ \\forall n\\ge n_0,\\ f(n) \\ge c\\,g(n)\n\n\n\nBig-Θ (tight bound):\nf(n) = \\Theta(g(n)) \\iff f(n)=O(g(n))\\ \\text{and}\\ f(n)=\\Omega(g(n))\n\n\n\nlittle-o (strictly smaller):\nf(n) = o(g(n)) \\iff \\lim_{n\\to\\infty} \\frac{f(n)}{g(n)} = 0\n\n\n\nlittle-ω (strictly larger):\nf(n) = \\omega(g(n)) \\iff \\lim_{n\\to\\infty} \\frac{f(n)}{g(n)} = \\infty\n\n\n\nWorst-case, average-case, and amortized bounds each use these notations—always specify which one you mean.\nCommon complexity classes (with examples)\n\nConstant: O(1) — array indexing, stack push/pop (amortized for dynamic arrays).\nInverse Ackermann: O(α(n)) — nearly constant; disjoint set union-find with path compression + union by rank.\nLogarithmic: O(log n) — binary search; height of balanced BSTs; divide-by-2 loops.\nPolylogarithmic: O(log^k n) — some multi-level structures and index trees.\nSublinear: O(√n) — trial division primality bound; 2D grid radius scans.\nLinear: O(n) — single pass over an array; counting; BFS on adjacency lists is O(V+E).\nLinearithmic: O(n log n) — mergesort, heapsort, typical quicksort average.\nQuadratic/Cubic/Polynomial: O(n^2), O(n^3), O(n^k) — nested loops over independent dimensions; classical matrix multiplication O(n^3).\nNear-linear with bounded keys: O(n + k) — counting/radix sort on small integer ranges; k = key range.\nQuasi-polynomial: O(2^{(\\log n)^c}) — arises in some approximation/derandomization results.\nExponential: O(c^n) — brute-force subset search, exact TSP via Held-Karp O(n^2 2^n).\nFactorial: O(n!) — enumerating permutations.\n\nRelated: fast multiplication O(n^{\\log_2 3}) (Karatsuba), fast matrix multiply O(n^\\omega) with ω &lt; 2.373 (theoretical).\nWorst-case, average-case, amortized\n\nWorst-case: bound on the slowest valid input of size n.\nAverage-case: expected complexity over a distribution of inputs (distribution must be stated).\nAmortized: average per operation over a sequence where occasional expensive ops occur.\n\nExample: dynamic array doubling. Total moves across n appends is &lt; 2n, so amortized append is O(1).\n\n\n\n\\text{Amortized cost} = \\frac{\\text{Total cost over } n \\text{ ops}}{n}\nPractical measurement and inference\nHow to empirically validate complexity:\n\nIsolate the workload\n\nExclude I/O and logging; measure pure compute.\nWarm up (JITs, caches); then time multiple runs.\n\n\nVary problem size n\n\nUse logarithmic steps (e.g., n = 2^k). Ensure enough data points.\nFor n \\log n, plot T(n)/n vs \\log n (flat line suggests n \\log n).\n\n\nUse log–log plots\n\nFit a line to (x, y) = (\\log n, \\log T(n)). Slope ≈ polynomial exponent.\ns \\approx \\frac{\\log T(n_2) - \\log T(n_1)}{\\log n_2 - \\log n_1}\n\n\n\nStatistics\n\nUse medians or trimmed means; report variance.\nRemove outliers; pin CPU; avoid thermal throttling.\n\n\nSpace profiling\n\nTrack peak usage, allocation counts, and per-element overhead.\nConsider GC/allocator metadata and fragmentation.\n\n\n\nCaution: microbenchmarks can be misleading due to dead-code elimination, branch prediction, prefetching, and caching. Validate with profilers and counters when possible.\nData structures at a glance (selected ops)\n\nStatic array\n\nIndex: O(1)\nSearch: O(n) (linear), O(log n) if sorted + binary search\nInsert/delete at index: O(n) due to shifts\n\n\nDynamic array (amortized doubling)\n\nAppend: O(1) amortized, O(n) worst when resizing\nInsert/delete in middle: O(n)\n\n\nSingly/doubly linked list\n\nPrepend: O(1); Append: O(1) with tail pointer; Search: O(n); Random index: O(n)\n\n\nStack / Queue / Deque\n\nPush/Pop/Enqueue/Dequeue: O(1) (amortized or worst-case depending on implementation)\n\n\nHash table (separate chaining / open addressing)\n\nAverage: find/insert/delete O(1) at healthy load factor\nWorst-case: O(n) (adversarial collisions)\nResizing: O(n) occasionally; amortized constant per op\n\n\nOrdered map/set (balanced BST: red–black, AVL, B-tree)\n\nFind/insert/delete: O(log n); predecessor/successor: O(log n); iteration: O(n)\n\n\nHeap (binary heap)\n\nFind-min: O(1); insert: O(log n); extract-min: O(log n); build-heap: O(n)\nDecrease-key: O(log n) (Fibonacci heap: amortized O(1), but large constants)\n\n\nDisjoint set (union–find)\n\nWith path compression + union by rank/size: O(α(n)) amortized per op\n\n\nTrie / prefix tree (alphabet size σ)\n\nInsert/lookup: O(L) for key length L; memory can be large (σ fans)\n\n\nBloom filter\n\nMembership test (no deletes): O(k) time, O(m) space, false positives allowed\np \\approx \\left(1 - e^{-kn/m}\\right)^k,\\quad k_{\\text{opt}} = \\frac{m}{n}\\ln 2,\\quad p_{\\min} \\approx (0.6185)^{m/n}\n\n\n\n\nGraph representations:\n\nAdjacency list: space O(V+E); BFS/DFS O(V+E)\nAdjacency matrix: space O(V^2); edge check O(1)\n\nClassic graph algorithm costs:\n\nBFS/DFS: O(V+E)\nDijkstra (nonnegative weights): binary heap O((V+E)\\log V), Fibonacci heap O(E + V \\log V)\n0–1 BFS: O(V+E) with deque\nMST: Kruskal O(E \\log V), Prim (binary heap) O(E \\log V)\n\nSorting and selection:\n\nComparison sorting lower bound: Ω(n \\log n)\nMergesort/heapsort: O(n \\log n); Quicksort: average O(n \\log n), worst O(n^2)\nCounting/radix sort: O(n + k) for key range k\nQuickselect (k-th order statistic): average O(n), worst O(n^2); Median-of-medians worst-case O(n)\n\nRecurrences and key formulas\nSums and approximations:\n\n\nSum of first n:\n\\sum_{i=1}^{n} i = \\frac{n(n+1)}{2}\n\n\n\nGeometric series:\n\\sum_{i=0}^{n} r^i = \\frac{r^{n+1} - 1}{r - 1}\\quad (r \\ne 1)\n\n\n\nHarmonic numbers:\nH_n = \\sum_{i=1}^{n} \\frac{1}{i} = \\ln n + \\gamma + \\Theta\\!\\left(\\frac{1}{n}\\right)\n\nwhere γ is the Euler–Mascheroni constant.\n\n\nLog-factorial / Stirling:\n\\log n! = \\Theta(n \\log n),\\quad\n  n! \\sim \\sqrt{2\\pi n}\\left(\\frac{n}{e}\\right)^{n}\n\n\n\nRecurrence examples:\n\n\nBinary search:\nT(n) = T(n/2) + \\Theta(1) \\ \\Rightarrow\\ T(n)=\\Theta(\\log n)\n\n\n\nMergesort:\nT(n) = 2T(n/2) + \\Theta(n) \\ \\Rightarrow\\ T(n)=\\Theta(n \\log n)\n\n\n\nKaratsuba multiplication:\nT(n) = 3T(n/2) + O(n) \\ \\Rightarrow\\ T(n)=O\\!\\left(n^{\\log_2 3}\\right)\\approx O(n^{1.585})\n\n\n\nStrassen matrix multiply:\nT(n) = 7T(n/2) + O(n^2) \\ \\Rightarrow\\ T(n)=O\\!\\left(n^{\\log_2 7}\\right)\\approx O(n^{2.807})\n\n\n\nMaster theorem (divide-and-conquer):\nT(n) = a\\,T(n/b) + f(n),\\ a\\ge 1,\\ b&gt;1 \\\\\nT(n) =\n\\begin{cases}\n\\Theta\\!\\left(n^{\\log_b a}\\right) &amp; \\text{if } f(n)=O\\!\\left(n^{\\log_b a - \\epsilon}\\right) \\\\\n\\Theta\\!\\left(n^{\\log_b a}\\log n\\right) &amp; \\text{if } f(n)=\\Theta\\!\\left(n^{\\log_b a}\\right) \\\\\n\\Theta\\!\\left(f(n)\\right) &amp; \\text{if } f(n)=\\Omega\\!\\left(n^{\\log_b a + \\epsilon}\\right)\\ \\text{and regularity holds}\n\\end{cases}\n\nAkra–Bazzi (general form intuition):\nGiven T(x) = \\sum_{i=1}^{k} a_i\\,T(b_i x) + g(x)\n, find p such that \\sum a_i b_i^p = 1\n. Then\nT(x) = \\Theta\\!\\left(x^p\\left(1 + \\int_{1}^{x} \\frac{g(u)}{u^{p+1}}\\,du\\right)\\right)\n\nParallelism: work and span\nLet T1 be total work (1 core), T∞ be span/critical path (infinite cores). With P processors:\n\nLower bound:\nT_P \\ge \\max\\!\\left(\\frac{T_1}{P},\\ T_{\\infty}\\right)\n\nAmdahl’s law (fixed workload, parallel fraction P_f):\nS(N) = \\frac{1}{(1-P_f) + \\frac{P_f}{N}}\n\nGustafson’s law (scaled workloads):\nS(N) = N - (1-P_f)(N-1)\n\n\nImplication: asymptotic improvements that reduce span (dependencies) often matter more than raw work on highly parallel hardware.\nMemory hierarchy and I/O awareness\n\nAlgorithms with the same O(n) can vary by orders of magnitude based on locality and block transfers.\nCache-aware/oblivious designs optimize transfers between layers (L1/L2/LLC/DRAM/disk).\nExternal memory (I/O) model tracks block size B and memory size M; aim to minimize cache misses and scans.\n\nCommon pitfalls\n\nIgnoring constants and memory: O(n) with scattered random access can be slower than O(n log n) with tight sequential scans for real n.\nComparing apples to oranges: average-case of algorithm A vs worst-case of algorithm B.\nAssuming distribution: hash tables need a good hash function and controlled load factors; adversarial inputs can degrade to O(n).\nMistaking amortized for worst-case: dynamic array append is not guaranteed O(1) per operation.\nSmall n realities: lower-order terms dominate; choose simpler algorithms for tiny inputs.\nOverfitting benchmarks: JIT, branch prediction, dead-code elimination, and warmup can skew results.\nIgnoring I/O/network: Many systems are I/O-bound or latency-bound, not CPU-bound.\n\nPutting it to work: a quick checklist\n\nDefine the input model and size parameters (n, V, E, key range k, string length L).\nChoose meaningful complexity targets (worst/average/amortized) and justify them.\nConsider data-structure trade-offs (time vs space vs simplicity).\nValidate with both math (recurrences, bounds) and measurement (multiple n, log–log fits).\nWatch memory behavior (peak, locality, allocations) and parallel scalability (span).\nAdd assertions/metrics to prevent regressions (budget in CI, performance tests).\n\nMathematical appendix (handy references)\n\n\nSum of logs:\n\\sum_{i=1}^{n} \\log i = \\log n! = \\Theta(n \\log n)\n\n\n\nSum of squares and cubes:\n\\sum_{i=1}^{n} i^2 = \\frac{n(n+1)(2n+1)}{6},\\quad\n  \\sum_{i=1}^{n} i^3 = \\left(\\frac{n(n+1)}{2}\\right)^2\n\n\n\nComparing n^a vs n \\log n:\n\nIf a &gt; 1, then n^a = ω(n \\log n).\nIf a = 1, then n \\log n = ω(n).\n\n\n\nWith these tools—precise notation, realistic measurement, and a sense for data-structure trade-offs—you can analyze, compare, and improve algorithms with confidence.\n"},{"url":"https://zokipedia.hahwul.com/lorem-ipsum/","title":"[Example] Lorem ipsum","body":"What is Lorem ipsum?\nLorem ipsum is a placeholder (dummy) text used to prototype layouts, typography, and components before real content is available. It lets designers and engineers separate visual and structural decisions from editorial decisions, so spacing, rhythm, and responsiveness can be validated without cognitive bias from meaningful words.\n\nUse it to: test grids, line-length, line-height, font pairing, component breakpoints, and content flow.\nDon’t use it to: validate tone, clarity, conversion copy, or compliance language (you need real copy for that).\n\nHistory and origin\nThe text commonly known as “Lorem ipsum” is derived—via truncation and scrambling—from Cicero’s 45 BCE work “De finibus bonorum et malorum.” Commercial use surged in the 1960s with Letraset transfer sheets, then spread widely in the 1980s through desktop publishing templates (e.g., Aldus PageMaker). It later appeared in word processors, CMS themes, and UI kits, becoming the de facto filler for Latin-script layouts.\nThe phrase “Lorem ipsum” is generally considered a clipping of “dolorem ipsum” (“pain itself”). Modern variants intentionally corrupt grammar and word order to avoid conveying meaningful Latin.\nWhy teams still use it\n\nDecouples layout from meaning: prevents early feedback from fixating on copy instead of hierarchy and spacing.\nNormalizes texture: approximates word/letter frequency of Latin-script languages to represent realistic text color (visual density) on a page.\nEnables faster iteration: allows early, repeatable tests of typographic scale, vertical rhythm, and scroll behavior.\n\nWhen not to use it\nUse real content—or realistic domain text—when any of the following are true:\n\nYou’re validating UX copy (labels, errors, onboarding, pricing).\nLegal/compliance text is required (privacy, consent, regulated industries).\nLocalization affects layout (e.g., CJK, RTL, long German compounds).\nAccessibility reviews are in scope (screen reader behavior, language detection).\nAnalytics, SEO, or preview cards will be crawled or shared publicly.\n\nAccessibility and i18n considerations\n\nLanguage metadata: If placeholder text must be read by assistive tech, wrap it in an element with lang=\"la\" to hint pronunciation. If the text is purely decorative, mark it aria-hidden=\"true\"—but only when it conveys no information.\nRepetition fatigue: Large, repeated gibberish blocks can degrade screen reader experience; prefer short, varied samples or hide decorative fillers.\nContrast and focus: Placeholder text should not be styled in a way that reduces contrast required for readability testing.\nRTL and CJK: Latin-centric filler won’t expose bidirectional or glyph metrics issues. For Arabic/Hebrew, test with RTL content. For CJK, use language-appropriate placeholder text to validate line breaking and kinsoku rules.\nTruncation and overflow: Use realistic long words and mixed scripts to expose line-wrapping, ellipsis, and overflow clipping.\n\nPractical usage guidelines\n\nLength targeting: Match expected word counts (e.g., microcopy 4–12 words, paragraphs 60–120 words) to verify line length (45–75 characters per line is a common reading comfort range).\nVariation: Mix sentence lengths and punctuation to simulate natural rhythm and hyphenation.\nContent tokens: In design systems, expose tokens like --placeholder-text-short, --placeholder-text-long, and --placeholder-heading to standardize samples across components.\nEnvironments: Ensure placeholder content appears only in development/staging. Add build checks to fail if “lorem ipsum” ships to production.\n\nPitfalls and how to avoid them\n\nShipping placeholder text: Add CI rules that search for “lorem”/“ipsum” and break the build when found in production bundles or templates.\nFalse positives in tests: If tests assert against placeholder strings, they may become brittle. Prefer test IDs or structural assertions.\nMisleading approvals: Stakeholders may approve visual hierarchy but later reject final copy that changes density. Reduce risk by swapping in real draft copy as early as possible.\n\nAlternatives to Lorem ipsum\n\nDomain-realistic placeholders: Use archived or anonymized text from your domain (e.g., blog intros, product blurbs).\nLanguage-specific fillers:\n\nCJK: language-appropriate filler to test line breaking and punctuation rules.\nRTL: Arabic/Hebrew text to verify bidi handling and glyph shaping.\n\n\nPangrams: Useful for type specimen (e.g., “The quick brown fox…”). Not a substitute for paragraph testing.\nThemed generators: “Bacon Ipsum,” “Corporate Ipsum,” etc.—fun but best kept to internal demos.\nContent skeletons: Use meaningful headings with short neutral body text to reduce cognitive noise while keeping structure realistic.\n\nExample paragraphs\nA medium paragraph (approx. 80–100 words) to assess line-length and rhythm:\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Integer in commodo nibh. Sed vitae sem fermentum, posuere metus a, malesuada lacus. Quisque dictum, arcu a hendrerit consequat, leo dui ultricies est, sed lobortis massa neque non nisi. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Proin sed feugiat justo. Aliquam erat volutpat. Donec a luctus erat, quis aliquet orci. Duis viverra, nunc a placerat aliquam, sapien lorem cursus ipsum, at facilisis velit arcu in lectus.\n\nA short paragraph (approx. 40–60 words) for cards or teasers:\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse vitae augue vehicula, condimentum odio ut, sodales urna. Donec pulvinar, velit at euismod suscipit, lacus nunc blandit risus, a faucibus massa arcu et nunc.\n\nBullet-style snippets for lists and empty states:\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit.\nCurabitur non risus nec magna iaculis placerat.\nVivamus posuere sapien et urna congue, nec dictum leo pretium.\n\nEstimating length and reading time\n\nRough words from characters: words ≈ characters / 5 (English-like text).\nApproximate reading time: minutes ≈ words / 200 (average adult silent reading).\n\nUse these only to size blocks; always validate with real copy before release.\nSEO and analytics hygiene\n\nExclude from indexing: Apply noindex/nofollow to non-production environments and preview routes.\nShare cards: Prevent Open Graph/Twitter cards from exposing placeholder text.\nSitemaps: Don’t include placeholder pages in production sitemaps.\n\nTeam checklist\nDo:\n\nReplace placeholder text with draft content before usability testing.\nSet lang appropriately or hide decorative filler from assistive tech.\nAdd CI checks to prevent “lorem ipsum” in production.\n\nDon’t:\n\nApprove critical flows (checkout, consent) with placeholder copy.\nRely on Latin filler for non-Latin layouts.\nUse placeholders in analytics experiments or A/B tests.\n\nExample Latin passage\nA canonical block often used for typography specimens:\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n\nMath demo (typography rendering)\nThe following formula is included to exercise math rendering in layouts:\n\\sum_{i=0}^{n} r^i = \\frac{r^{n+1} - 1}{r - 1} \\quad \\text{for } r \\neq 1\n"}]